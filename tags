!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AucP	regr/auc.c	/^}AucP;$/;"	t	typeref:struct:_aucP	file:
CC	cls/Makefile	/^CC = gcc -std=c99 -g$/;"	m
CC	gbdt/Makefile	/^CC = gcc -std=c99 -g$/;"	m
CC	regr/Makefile	/^CC = gcc -std=c99 -g$/;"	m
CC	src/Makefile	/^CC = gcc -std=c99 -g$/;"	m
CC	tm/Makefile	/^CC = gcc -std=c99 -g$/;"	m
CC	ts/Makefile	/^CC       = gcc -std=c99$/;"	m
CC	util/Makefile	/^CC = gcc -std=c99 -g$/;"	m
CFBASE	cls/Makefile	/^CFBASE = -pedantic -pipe -Wall$/;"	m
CFBASE	gbdt/Makefile	/^CFBASE = -pedantic -pipe -Wall$/;"	m
CFBASE	regr/Makefile	/^CFBASE = -pedantic -pipe -Wall$/;"	m
CFBASE	src/Makefile	/^CFBASE = -Wall -pedantic -pipe$/;"	m
CFBASE	tm/Makefile	/^CFBASE = -pedantic -pipe -Wall$/;"	m
CFBASE	ts/Makefile	/^CFBASE   = -Wall -pedantic -pipe$/;"	m
CFBASE	util/Makefile	/^CFBASE = -pedantic -pipe -Wall$/;"	m
CFLAGS	cls/Makefile	/^CFLAGS = $(CFBASE) -O0 -fpic -DNDEBUG -DNPRINT -I..\/util$/;"	m
CFLAGS	gbdt/Makefile	/^CFLAGS = $(CFBASE) -O3 -fpic -DNDEBUG -DNPRINT -I..\/util -I..\/regr$/;"	m
CFLAGS	regr/Makefile	/^CFLAGS = $(CFBASE) -O0 -fpic -DNDEBUG -DNPRINT -I..\/util$/;"	m
CFLAGS	src/Makefile	/^CFLAGS = $(CFBASE) -DNDEBUG -DNPRINT -O3 -I$(INC)$/;"	m
CFLAGS	tm/Makefile	/^CFLAGS = $(CFBASE) -O3 -fpic -DNDEBUG -DNPRINT -I..\/util$/;"	m
CFLAGS	ts/Makefile	/^CFLAGS   = $(CFBASE) -DNDEBUG -DNPRINT -O0 -fpic -I..\/util$/;"	m
CFLAGS	util/Makefile	/^CFLAGS = $(CFBASE) -O3 -fpic -DNDEBUG -DNPRINT$/;"	m
CLSDIR	Makefile	/^CLSDIR   = cls$/;"	m
CMP_FN	output/inc/rbtree.h	/^typedef int    (*CMP_FN)(void *, void*);$/;"	t
CMP_FN	util/rbtree.h	/^typedef int    (*CMP_FN)(void *, void*);$/;"	t
ClsList	ts/pattern.c	/^} ClsList;$/;"	t	typeref:struct:_cls_list	file:
ClsListS	ts/pattern.c	/^} ClsListS;$/;"	t	typeref:struct:_cls_list_s	file:
Const	ts/breakout.c	/^static double Const(double x){$/;"	f	file:
DBL_MAX	gbdt/dtree.c	/^#define  DBL_MAX /;"	d	file:
DTD	gbdt/tdata.h	/^}DTD;$/;"	t	typeref:struct:__anon2
DTD	output/inc/tdata.h	/^}DTD;$/;"	t	typeref:struct:__anon9
DTD_FEA_VAL	gbdt/tdata.c	/^} DTD_FEA_VAL;$/;"	t	typeref:struct:__anon1	file:
DT_LINE_LEN	gbdt/tdata.c	/^#define DT_LINE_LEN /;"	d	file:
DTree	gbdt/dtree.h	/^typedef struct _d_tree DTree;$/;"	t	typeref:struct:_d_tree
DTree	output/inc/dtree.h	/^typedef struct _d_tree DTree;$/;"	t	typeref:struct:_d_tree
EPS	regr/newton.c	/^#define EPS /;"	d	file:
EVAL_FN	output/inc/regr_fn.h	/^typedef double (*EVAL_FN)(double *x, void *data);$/;"	t
EVAL_FN	regr/regr_fn.h	/^typedef double (*EVAL_FN)(double *x, void *data);$/;"	t
FKL	gbdt/tdata.h	/^#define FKL /;"	d
FKL	output/inc/tdata.h	/^#define FKL /;"	d
FREE_FN	output/inc/rbtree.h	/^typedef void   (*FREE_FN)(void *);$/;"	t
FREE_FN	util/rbtree.h	/^typedef void   (*FREE_FN)(void *);$/;"	t
G	gbdt/gbdt.h	/^typedef void(*G)(double * f, double * y, double * g, int n);$/;"	t
G	output/inc/gbdt.h	/^typedef void(*G)(double * f, double * y, double * g, int n);$/;"	t
GBDT	gbdt/gbdt.h	/^typedef struct _gbdt GBDT;$/;"	t	typeref:struct:_gbdt
GBDT	output/inc/gbdt.h	/^typedef struct _gbdt GBDT;$/;"	t	typeref:struct:_gbdt
GBDTDIR	Makefile	/^GBDTDIR  = gbdt$/;"	m
GBMP	gbdt/gbdt.h	/^} GBMP;$/;"	t	typeref:struct:_gbdt_param
GBMP	output/inc/gbdt.h	/^} GBMP;$/;"	t	typeref:struct:_gbdt_param
GRAD_FN	output/inc/regr_fn.h	/^typedef void   (*GRAD_FN)(double *x, void *data, double *g, double *sg);$/;"	t
GRAD_FN	regr/regr_fn.h	/^typedef void   (*GRAD_FN)(double *x, void *data, double *g, double *sg);$/;"	t
H	gbdt/gbdt.h	/^typedef void(*H)(double * f, double * y, double * h, int n);$/;"	t
H	output/inc/gbdt.h	/^typedef void(*H)(double * f, double * y, double * h, int n);$/;"	t
HASH_SPACE	util/hash.c	/^#define HASH_SPACE /;"	d	file:
HEAP_ADJUST	util/heap.c	/^#define HEAP_ADJUST(/;"	d	file:
HEAP_CMP_FN	output/inc/heap.h	/^typedef int  (*HEAP_CMP_FN) (void *, void*);$/;"	t
HEAP_CMP_FN	util/heap.h	/^typedef int  (*HEAP_CMP_FN) (void *, void*);$/;"	t
HEAP_H	output/inc/heap.h	/^#define HEAP_H$/;"	d
HEAP_H	util/heap.h	/^#define HEAP_H$/;"	d
HEAP_ITEM_FREE	output/inc/heap.h	/^typedef void (*HEAP_ITEM_FREE)(void *);$/;"	t
HEAP_ITEM_FREE	util/heap.h	/^typedef void (*HEAP_ITEM_FREE)(void *);$/;"	t
Hash	output/inc/hash.h	/^typedef struct _hash Hash;$/;"	t	typeref:struct:_hash
Hash	util/hash.h	/^typedef struct _hash Hash;$/;"	t	typeref:struct:_hash
HashType	output/inc/hash.h	/^typedef enum { INT, LONG, STRING } HashType;$/;"	t	typeref:enum:__anon3
HashType	util/hash.h	/^typedef enum { INT, LONG, STRING } HashType;$/;"	t	typeref:enum:__anon15
HashVal	util/hash.c	/^} HashVal;$/;"	t	typeref:union:_hash_val	file:
Heap	output/inc/heap.h	/^} Heap;$/;"	t	typeref:struct:_heap
Heap	util/heap.h	/^} Heap;$/;"	t	typeref:struct:_heap
INC	src/Makefile	/^INC = ..\/inc$/;"	m
INCS	ts/Makefile	/^INCS     = -I..\/util$/;"	m
INS	src/Makefile	/^INS = ..\/output$/;"	m
INSTDIR	Makefile	/^INSTDIR  = .$/;"	m
INT	output/inc/hash.h	/^typedef enum { INT, LONG, STRING } HashType;$/;"	e	enum:__anon3
INT	util/hash.h	/^typedef enum { INT, LONG, STRING } HashType;$/;"	e	enum:__anon15
Interval	ts/modl.c	/^typedef int Interval[6];$/;"	t	file:
KEY_SIZE	output/inc/lda.h	/^#define KEY_SIZE /;"	d
KEY_SIZE	tm/lda.h	/^#define KEY_SIZE /;"	d
LANode	util/hash.c	/^} LANode;$/;"	t	typeref:union:_la_node	file:
LBFGS	output/inc/newton.h	/^typedef enum { OWLQN = 1, LBFGS } NT_METHOD;$/;"	e	enum:__anon6
LBFGS	regr/newton.h	/^typedef enum { OWLQN = 1, LBFGS } NT_METHOD;$/;"	e	enum:__anon10
LD	cls/Makefile	/^LD = gcc -shared$/;"	m
LD	gbdt/Makefile	/^LD = gcc -shared$/;"	m
LD	regr/Makefile	/^LD = gcc -shared$/;"	m
LD	tm/Makefile	/^LD = gcc -shared$/;"	m
LD	ts/Makefile	/^LD       = gcc -shared$/;"	m
LD	util/Makefile	/^LD = gcc -shared$/;"	m
LDA_LINE_LEN	tm/lda.c	/^#define LDA_LINE_LEN /;"	d	file:
LIB	src/Makefile	/^LIB = ..\/lib$/;"	m
LIBS	ts/Makefile	/^LIBS     = -L..\/util$/;"	m
LONG	output/inc/hash.h	/^typedef enum { INT, LONG, STRING } HashType;$/;"	e	enum:__anon3
LONG	util/hash.h	/^typedef enum { INT, LONG, STRING } HashType;$/;"	e	enum:__anon15
Lda	output/inc/lda.h	/^} Lda;$/;"	t	typeref:struct:_lda
Lda	tm/lda.h	/^} Lda;$/;"	t	typeref:struct:_lda
Linear	ts/breakout.c	/^static double Linear(double x){$/;"	f	file:
MTrace	output/inc/median.h	/^} MTrace;$/;"	t	typeref:struct:_median
MTrace	util/median.h	/^} MTrace;$/;"	t	typeref:struct:_median
ModelEle	output/inc/lda.h	/^} ModelEle;$/;"	t	typeref:struct:__anon5
ModelEle	tm/lda.h	/^} ModelEle;$/;"	t	typeref:struct:__anon14
NT_METHOD	output/inc/newton.h	/^typedef enum { OWLQN = 1, LBFGS } NT_METHOD;$/;"	t	typeref:enum:__anon6
NT_METHOD	regr/newton.h	/^typedef enum { OWLQN = 1, LBFGS } NT_METHOD;$/;"	t	typeref:enum:__anon10
Node	ts/pattern.c	/^} Node;$/;"	t	typeref:struct:_node	file:
OWLQN	output/inc/newton.h	/^typedef enum { OWLQN = 1, LBFGS } NT_METHOD;$/;"	e	enum:__anon6
OWLQN	regr/newton.h	/^typedef enum { OWLQN = 1, LBFGS } NT_METHOD;$/;"	e	enum:__anon10
PRGS	src/Makefile	/^PRGS   = lr lda gblr$/;"	m
ParamLda	output/inc/lda.h	/^} ParamLda;$/;"	t	typeref:struct:__anon4
ParamLda	tm/lda.h	/^} ParamLda;$/;"	t	typeref:struct:__anon13
Quadratic	ts/breakout.c	/^static double Quadratic(double x){$/;"	f	file:
R	gbdt/gbdt.h	/^typedef void(*R)(GBDT * m);$/;"	t
R	output/inc/gbdt.h	/^typedef void(*R)(GBDT * m);$/;"	t
RBLANode	util/rbtree.c	/^} RBLANode;$/;"	t	typeref:union:_la_node	file:
RBNode	util/rbtree.c	/^} RBNode;$/;"	t	typeref:struct:_RBNode	file:
RBTree	output/inc/rbtree.h	/^typedef struct _RBTree RBTree;$/;"	t	typeref:struct:_RBTree
RBTree	util/rbtree.h	/^typedef struct _RBTree RBTree;$/;"	t	typeref:struct:_RBTree
RB_BLACK	util/rbtree.c	/^typedef enum {RB_RED, RB_BLACK} RB_NODE_COLOR;$/;"	e	enum:__anon16	file:
RB_NODE_COLOR	util/rbtree.c	/^typedef enum {RB_RED, RB_BLACK} RB_NODE_COLOR;$/;"	t	typeref:enum:__anon16	file:
RB_RED	util/rbtree.c	/^typedef enum {RB_RED, RB_BLACK} RB_NODE_COLOR;$/;"	e	enum:__anon16	file:
RB_SPACE	util/rbtree.c	/^#define RB_SPACE /;"	d	file:
RDS	output/inc/regress.h	/^} RDS;$/;"	t	typeref:struct:__anon8
RDS	regr/regress.h	/^} RDS;$/;"	t	typeref:struct:__anon12
REG	output/inc/regress.h	/^} REG;$/;"	t	typeref:struct:_reg
REG	regr/regress.h	/^} REG;$/;"	t	typeref:struct:_reg
REGRDIR	Makefile	/^REGRDIR  = regr$/;"	m
REG_LINE_LEN	regr/regress.c	/^#define REG_LINE_LEN /;"	d	file:
REPO_FN	output/inc/regr_fn.h	/^typedef int    (*REPO_FN)(double *x0, double *x1, void *data);$/;"	t
REPO_FN	regr/regr_fn.h	/^typedef int    (*REPO_FN)(double *x0, double *x1, void *data);$/;"	t
RKL	output/inc/regress.h	/^#define RKL /;"	d
RKL	regr/regress.h	/^#define RKL /;"	d
RP	output/inc/regress.h	/^} RP;$/;"	t	typeref:struct:__anon7
RP	regr/regress.h	/^} RP;$/;"	t	typeref:struct:__anon11
SRC	Makefile	/^SRC      = src$/;"	m
STRING	output/inc/hash.h	/^typedef enum { INT, LONG, STRING } HashType;$/;"	e	enum:__anon3
STRING	util/hash.h	/^typedef enum { INT, LONG, STRING } HashType;$/;"	e	enum:__anon15
SimpleHashMap	ts/pattern.c	/^} SimpleHashMap;$/;"	t	typeref:struct:_simple_hash_map	file:
TMDIR	Makefile	/^TMDIR    = tm$/;"	m
TSDIR	Makefile	/^TSDIR    = ts$/;"	m
ULL	ts/pattern.c	/^typedef unsigned long long ULL;$/;"	t	file:
UTIL	ts/Makefile	/^UTIL     = ..\/util$/;"	m
UTILDIR	Makefile	/^UTILDIR  = util$/;"	m
_AUC_H	output/inc/auc.h	/^#define _AUC_H$/;"	d
_AUC_H	regr/auc.h	/^#define _AUC_H$/;"	d
_BREAKOUT_H	output/inc/breakout.h	/^#define _BREAKOUT_H$/;"	d
_BREAKOUT_H	ts/breakout.h	/^#define _BREAKOUT_H$/;"	d
_DIST_H	output/inc/dist.h	/^#define _DIST_H$/;"	d
_DIST_H	ts/dist.h	/^#define _DIST_H$/;"	d
_DTREE_H	gbdt/dtree.h	/^#define _DTREE_H$/;"	d
_DTREE_H	output/inc/dtree.h	/^#define _DTREE_H$/;"	d
_GBDT_H	gbdt/gbdt.h	/^#define _GBDT_H$/;"	d
_GBDT_H	output/inc/gbdt.h	/^#define _GBDT_H$/;"	d
_GBLR_H	gbdt/gblr.h	/^#define _GBLR_H$/;"	d
_GBLR_H	output/inc/gblr.h	/^#define _GBLR_H$/;"	d
_HASH_H	output/inc/hash.h	/^#define _HASH_H$/;"	d
_HASH_H	util/hash.h	/^#define _HASH_H$/;"	d
_KMEANS_H	cls/kmeans.h	/^#define _KMEANS_H$/;"	d
_KMEANS_H	output/inc/kmeans.h	/^#define _KMEANS_H$/;"	d
_LDA_H	output/inc/lda.h	/^#define _LDA_H$/;"	d
_LDA_H	tm/lda.h	/^#define _LDA_H$/;"	d
_LOESS_H	output/inc/loess.h	/^#define _LOESS_H$/;"	d
_LOESS_H	ts/loess.h	/^#define _LOESS_H$/;"	d
_LR_H	output/inc/lr.h	/^#define _LR_H$/;"	d
_LR_H	regr/lr.h	/^#define _LR_H$/;"	d
_MEDIAN_H	output/inc/median.h	/^#define _MEDIAN_H$/;"	d
_MEDIAN_H	util/median.h	/^#define _MEDIAN_H$/;"	d
_MODL_H	output/inc/modl.h	/^#define _MODL_H$/;"	d
_MODL_H	ts/modl.h	/^#define _MODL_H$/;"	d
_NEWTON_H	output/inc/newton.h	/^#define _NEWTON_H$/;"	d
_NEWTON_H	regr/newton.h	/^#define _NEWTON_H$/;"	d
_PATTERN_H	output/inc/pattern.h	/^#define _PATTERN_H$/;"	d
_PATTERN_H	ts/pattern.h	/^#define _PATTERN_H$/;"	d
_RBNode	util/rbtree.c	/^typedef struct _RBNode{$/;"	s	file:
_RBTREE_H	output/inc/rbtree.h	/^#define _RBTREE_H$/;"	d
_RBTREE_H	util/rbtree.h	/^#define _RBTREE_H$/;"	d
_RBTree	util/rbtree.c	/^struct _RBTree{$/;"	s	file:
_REGRESS_H	output/inc/regress.h	/^#define _REGRESS_H$/;"	d
_REGRESS_H	regr/regress.h	/^#define _REGRESS_H$/;"	d
_REGR_FN_H	output/inc/regr_fn.h	/^#define _REGR_FN_H$/;"	d
_REGR_FN_H	regr/regr_fn.h	/^#define _REGR_FN_H$/;"	d
_STR_H	output/inc/str.h	/^#define _STR_H$/;"	d
_STR_H	util/str.h	/^#define _STR_H$/;"	d
_TDATA_H	gbdt/tdata.h	/^#define _TDATA_H$/;"	d
_TDATA_H	output/inc/tdata.h	/^#define _TDATA_H$/;"	d
_VITERBI_H	output/inc/viterbi.h	/^#define _VITERBI_H$/;"	d
_VITERBI_H	ts/viterbi.h	/^#define _VITERBI_H$/;"	d
_aucP	regr/auc.c	/^typedef struct _aucP {$/;"	s	file:
_cls_list	ts/pattern.c	/^typedef struct _cls_list {$/;"	s	file:
_cls_list_s	ts/pattern.c	/^typedef struct _cls_list_s {$/;"	s	file:
_d_tree	gbdt/dtree.c	/^struct _d_tree {$/;"	s	file:
_del_node_t	util/rbtree.c	/^static void _del_node_t(RBTree * t, RBNode * z){$/;"	f	file:
_extend_node_space	util/rbtree.c	/^static int _extend_node_space(RBTree * t){$/;"	f	file:
_gbdt	gbdt/gbdt.c	/^struct _gbdt {$/;"	s	file:
_gbdt_param	gbdt/gbdt.h	/^typedef struct _gbdt_param {$/;"	s
_gbdt_param	output/inc/gbdt.h	/^typedef struct _gbdt_param {$/;"	s
_hash	util/hash.c	/^struct _hash {$/;"	s	file:
_hash_val	util/hash.c	/^typedef union _hash_val {$/;"	u	file:
_heap	output/inc/heap.h	/^typedef struct _heap {$/;"	s
_heap	util/heap.h	/^typedef struct _heap {$/;"	s
_la_node	util/hash.c	/^typedef union _la_node {$/;"	u	file:
_la_node	util/rbtree.c	/^typedef union _la_node{$/;"	u	file:
_lda	output/inc/lda.h	/^typedef struct _lda {$/;"	s
_lda	tm/lda.h	/^typedef struct _lda {$/;"	s
_median	output/inc/median.h	/^typedef struct _median {$/;"	s
_median	util/median.h	/^typedef struct _median {$/;"	s
_node	ts/pattern.c	/^typedef struct _node {$/;"	s	file:
_reg	output/inc/regress.h	/^typedef struct _reg {$/;"	s
_reg	regr/regress.h	/^typedef struct _reg {$/;"	s
_relocal_node_free	util/rbtree.c	/^static void _relocal_node_free(RBTree * t, RBLANode * ns){$/;"	f	file:
_relocal_node_t	util/rbtree.c	/^static void _relocal_node_t(RBTree * t, RBNode * z, RBLANode * ns){$/;"	f	file:
_simple_hash_map	ts/pattern.c	/^typedef struct _simple_hash_map {$/;"	s	file:
a	output/inc/lda.h	/^    double a;              \/* alpha   *\/     $/;"	m	struct:__anon4
a	tm/lda.h	/^    double a;              \/* alpha   *\/     $/;"	m	struct:__anon13
attr	gbdt/dtree.c	/^    int attr;                       \/* if not leaf, split attr   *\/$/;"	m	struct:_d_tree	file:
attr_val	gbdt/dtree.c	/^    double attr_val;                \/* split val of this attr    *\/$/;"	m	struct:_d_tree	file:
auc	regr/auc.c	/^double auc(int n, double *x, double *y) {$/;"	f
b	output/inc/lda.h	/^    double b;              \/* beta    *\/     $/;"	m	struct:__anon4
b	tm/lda.h	/^    double b;              \/* beta    *\/     $/;"	m	struct:__anon13
backtrack	regr/newton.c	/^static double backtrack(void *data, EVAL_FN eval_fn, int n, double *x, double *g, double *dir, double *newx, NT_METHOD method){$/;"	f	file:
balance	util/median.c	/^static void balance(MTrace * m){$/;"	f	file:
bcp	ts/breakout.c	/^void bcp(double *X, int T,int *points) {$/;"	f
bfgs	regr/newton.c	/^int bfgs(void *data, EVAL_FN eval_fn, GRAD_FN grad_fn, double ftol, int n, int it, double *retx) {$/;"	f
bin	gbdt/tdata.h	/^    int bin;                        \/* binary data or not        *\/$/;"	m	struct:__anon2
bin	output/inc/tdata.h	/^    int bin;                        \/* binary data or not        *\/$/;"	m	struct:__anon9
binary	gbdt/gbdt.h	/^    int binary;$/;"	m	struct:_gbdt_param
binary	output/inc/gbdt.h	/^    int binary;$/;"	m	struct:_gbdt_param
binary	output/inc/regress.h	/^    int    binary;              \/* binary feature or not    *\/$/;"	m	struct:__anon7
binary	regr/regress.h	/^    int    binary;              \/* binary feature or not    *\/$/;"	m	struct:__anon11
c	output/inc/regress.h	/^    int     c;                  \/* unique feature count     *\/$/;"	m	struct:_reg
c	regr/regress.h	/^    int     c;                  \/* unique feature count     *\/$/;"	m	struct:_reg
charmask	util/str.c	/^static inline int charmask(unsigned char *input, int len, char *mask)$/;"	f	file:
child	gbdt/dtree.c	/^    struct _d_tree * child[2];      \/* splited children nodes    *\/$/;"	m	struct:_d_tree	typeref:struct:_d_tree::_d_tree	file:
child	util/rbtree.c	/^    struct _RBNode * child[2];$/;"	m	struct:_RBNode	typeref:struct:_RBNode::_RBNode	file:
cl	gbdt/tdata.h	/^    int * cl;                       \/* cumulative row cnt ..     *\/$/;"	m	struct:__anon2
cl	output/inc/tdata.h	/^    int * cl;                       \/* cumulative row cnt ..     *\/$/;"	m	struct:__anon9
cls_insert	ts/pattern.c	/^void cls_insert(ClsList *t, int row, int offset) {$/;"	f
cls_s	ts/pattern.c	/^    ClsList *cls_s;$/;"	m	struct:_cls_list_s	file:
cls_s_create	ts/pattern.c	/^ClsListS *cls_s_create(int n) {$/;"	f
cls_s_free	ts/pattern.c	/^void cls_s_free(ClsListS *t) {$/;"	f
cmp	regr/auc.c	/^int cmp(const void *_a, const void *_b) {$/;"	f
cmp_fn	output/inc/median.h	/^    CMP_FN cmp_fn;$/;"	m	struct:_median
cmp_fn	ts/breakout.c	/^static int cmp_fn(double *m, double *n){$/;"	f	file:
cmp_fn	ts/loess.c	/^int cmp_fn(double *m, double *n) {$/;"	f
cmp_fn	util/median.h	/^    CMP_FN cmp_fn;$/;"	m	struct:_median
cmp_fn	util/rbtree.c	/^    CMP_FN  cmp_fn;$/;"	m	struct:_RBTree	file:
cnt1	output/inc/median.h	/^    int cnt1;$/;"	m	struct:_median
cnt1	util/median.h	/^    int cnt1;$/;"	m	struct:_median
cnt2	output/inc/median.h	/^    int cnt2;$/;"	m	struct:_median
cnt2	util/median.h	/^    int cnt2;$/;"	m	struct:_median
col	gbdt/tdata.h	/^    int col;                        \/* feature count of data     *\/$/;"	m	struct:__anon2
col	output/inc/tdata.h	/^    int col;                        \/* feature count of data     *\/$/;"	m	struct:__anon9
color	util/rbtree.c	/^    RB_NODE_COLOR color;$/;"	m	struct:_RBNode	file:
constant_hazard	ts/breakout.c	/^static void constant_hazard(double *nr, int n, double lambda) {$/;"	f	file:
copy_val	util/hash.c	/^static HashVal copy_val(Hash * hs, HashVal s){$/;"	f	file:
count	output/inc/lda.h	/^    unsigned int   count;$/;"	m	struct:__anon5
count	tm/lda.h	/^    unsigned int   count;$/;"	m	struct:__anon14
count	util/hash.c	/^    int count;          \/\/ number of elements inserted$/;"	m	struct:_hash	file:
create_lda	tm/lda.c	/^Lda *create_lda() {$/;"	f
create_lr_model	regr/lr.c	/^REG * create_lr_model(){$/;"	f
create_model	regr/regress.c	/^REG * create_model(EVAL_FN eval_fn, GRAD_FN grad_fn, REPO_FN repo_fn){$/;"	f
d	output/inc/lda.h	/^    int d;                         \/* doc size          *\/$/;"	m	struct:_lda
d	tm/lda.h	/^    int d;                         \/* doc size          *\/$/;"	m	struct:_lda
data	output/inc/heap.h	/^    void ** data;$/;"	m	struct:_heap
data	util/heap.h	/^    void ** data;$/;"	m	struct:_heap
default_cmp	util/rbtree.c	/^static int default_cmp(int *a, int *b) {$/;"	f	file:
default_heap_cmp_fn	util/heap.c	/^int default_heap_cmp_fn(int* m, int* n){$/;"	f
depth	gbdt/dtree.c	/^    int depth;                      \/* depth of this node        *\/$/;"	m	struct:_d_tree	file:
dist	cls/kmeans.c	/^static float dist(float * feature1, float * feature2, int f){$/;"	f	file:
doc_entry	output/inc/lda.h	/^    int  * doc_entry;              \/* doc entry         *\/$/;"	m	struct:_lda
doc_entry	tm/lda.h	/^    int  * doc_entry;              \/* doc entry         *\/$/;"	m	struct:_lda
dts	gbdt/gbdt.c	/^    DTree ** dts;$/;"	m	struct:_gbdt	file:
dtw	ts/dist.c	/^double dtw(double * x, int nx, double * y, int ny){$/;"	f
ed	ts/dist.c	/^int ed(char * x, char * y){$/;"	f
ed_bak	ts/dist.c	/^int ed_bak(char * x, char * y){$/;"	f
edm	ts/breakout.c	/^int * edm(double * ts, int n, int min_size, double beta, int degree, int *ol){$/;"	f
est_lda	tm/lda.c	/^void est_lda(Lda *lda) {$/;"	f
eval_fn	output/inc/regress.h	/^    EVAL_FN eval_fn;            \/* loss function            *\/$/;"	m	struct:_reg
eval_fn	regr/regress.h	/^    EVAL_FN eval_fn;            \/* loss function            *\/$/;"	m	struct:_reg
eval_test	gbdt/gbdt.c	/^static void eval_test(GBDT * gbdt){$/;"	f	file:
eval_tree	gbdt/dtree.c	/^double * eval_tree(DTD * ts, DTree * t, double * F, int n){$/;"	f
exMerge	ts/modl.c	/^static Interval * exMerge(Interval * I, int m, int n, int *l, double * LogD){$/;"	f	file:
ext_obj	gbdt/Makefile	/^ext_obj = ..\/util\/hash.o ..\/util\/str.o ..\/regr\/auc.o$/;"	m
extend_hash	util/hash.c	/^static void extend_hash(Hash * hs){$/;"	f	file:
f	gbdt/gbdt.c	/^    double * f;$/;"	m	struct:_gbdt	file:
fea_rows_sort	gbdt/tdata.c	/^static void fea_rows_sort(int * ids, double * vals, DTD_FEA_VAL * f, int n){$/;"	f	file:
filter_cluster	ts/pattern.c	/^int (*filter_cluster(ClsListS *cls, int l, int *nlen))[3] {$/;"	f
find_left_max	util/median.c	/^static void * find_left_max(MTrace * m){$/;"	f	file:
find_right_min	util/median.c	/^static void * find_right_min(MTrace * m){$/;"	f	file:
free_data	gbdt/tdata.c	/^void free_data(DTD *ts){$/;"	f
free_ds	regr/regress.c	/^static void free_ds(RDS * ds){$/;"	f	file:
free_dtree	gbdt/dtree.c	/^void free_dtree(DTree * t){$/;"	f
free_fn	output/inc/median.h	/^    FREE_FN free_fn;$/;"	m	struct:_median
free_fn	util/median.h	/^    FREE_FN free_fn;$/;"	m	struct:_median
free_fn	util/rbtree.c	/^    FREE_FN free_fn;$/;"	m	struct:_RBTree	file:
free_lda	tm/lda.c	/^void free_lda(Lda *lda) {$/;"	f
free_model	regr/regress.c	/^void free_model(REG * reg){$/;"	f
ftoler	output/inc/regress.h	/^    double ftoler;              \/* tolerance for conv       *\/$/;"	m	struct:__anon7
ftoler	regr/regress.h	/^    double ftoler;              \/* tolerance for conv       *\/$/;"	m	struct:__anon11
fullfill_param	tm/lda.c	/^static void fullfill_param(Lda *lda) {$/;"	f	file:
g_fn	gbdt/gbdt.c	/^    G g_fn;$/;"	m	struct:_gbdt	file:
gbdt_create	gbdt/gbdt.c	/^GBDT * gbdt_create(G g_fn, H h_fn, R r_fn, GBMP p){$/;"	f
gbdt_free	gbdt/gbdt.c	/^void   gbdt_free (GBDT * gbdt){$/;"	f
gbdt_lr	gbdt/gblr.c	/^GBDT * gbdt_lr(GBMP p){$/;"	f
gbdt_save	gbdt/gbdt.c	/^void   gbdt_save (GBDT * gbdt){$/;"	f
gbdt_train	gbdt/gbdt.c	/^int    gbdt_train(GBDT * gbdt){$/;"	f
gen_base	ts/pattern.c	/^ULL *gen_base(int l, int k) {$/;"	f
gen_cluster	ts/pattern.c	/^ClsListS *gen_cluster(double *d, int n, int m, int l, int k) {$/;"	f
generate_dtree	gbdt/dtree.c	/^DTree * generate_dtree(DTD * ds      \/* dataset for build tree *\/$/;"	f
getDelta	ts/modl.c	/^static double getDelta(Interval a, Interval b, Interval c, int m, int n, double * LogD){$/;"	f	file:
getValue	ts/modl.c	/^static double getValue(Interval * t,int m, int n, double * LogD){$/;"	f	file:
get_hg	regr/newton.c	/^static void get_hg(int n, double *g,  double *s, double *y, int m, int pos, int k, double hgini, double *hg, NT_METHOD method){$/;"	f	file:
get_inv_h	regr/newton.c	/^static void get_inv_h(int n, double *s, double *y, double *b) {$/;"	f	file:
get_median	util/median.c	/^void * get_median(MTrace * m){$/;"	f
get_pattern	ts/pattern.c	/^int (*get_pattern(double *d, int n, int m, int l, int k, int *nlen))[3] {$/;"	f
gibbs_sample	tm/lda.c	/^static int gibbs_sample(Lda * lda) {$/;"	f	file:
grad_fn	output/inc/regress.h	/^    GRAD_FN grad_fn;            \/* grandient function       *\/$/;"	m	struct:_reg
grad_fn	regr/regress.h	/^    GRAD_FN grad_fn;            \/* grandient function       *\/$/;"	m	struct:_reg
grad_fn	ts/loess.c	/^static void grad_fn (double *y, double *w, int k, double *grad) {$/;"	f	file:
greedInit	ts/modl.c	/^static Interval * greedInit(double v[], int a[], int n, int* m){$/;"	f	file:
h_create	ts/pattern.c	/^SimpleHashMap *h_create(int n, int mask) {$/;"	f
h_find	ts/pattern.c	/^int h_find(SimpleHashMap *shm, ULL val) {$/;"	f
h_fn	gbdt/gbdt.c	/^    H h_fn;$/;"	m	struct:_gbdt	file:
h_free	ts/pattern.c	/^void h_free(SimpleHashMap *shm) {$/;"	f
h_insert	ts/pattern.c	/^int h_insert(SimpleHashMap *shm, ULL val) {$/;"	f
has_test	gbdt/gbdt.c	/^int has_test(GBDT * gbdt){$/;"	f
hash_add	util/hash.c	/^int hash_add(Hash * hs, ...) { $/;"	f
hash_cnt	util/hash.c	/^int hash_cnt(Hash * hs){$/;"	f
hash_code	util/hash.c	/^static unsigned long long hash_code(Hash * hs, HashVal v){$/;"	f	file:
hash_create	util/hash.c	/^Hash * hash_create(int n, HashType type){$/;"	f
hash_del	util/hash.c	/^int hash_del(Hash * hs, ...){$/;"	f
hash_find	util/hash.c	/^int hash_find(Hash * hs, ...){$/;"	f
hash_free	util/hash.c	/^void hash_free(Hash * hs){$/;"	f
hash_func	util/hash.c	/^static unsigned long long hash_func(char *arKey)$/;"	f	file:
hash_sign	ts/pattern.c	/^ULL hash_sign(double *x, ULL *base, int l, int k) {$/;"	f
hash_size	util/hash.c	/^int  hash_size(Hash * hs){$/;"	f
head	ts/pattern.c	/^    Node *head;$/;"	m	struct:_cls_list	file:
head	ts/pattern.c	/^    int *head;$/;"	m	struct:_simple_hash_map	file:
head	util/hash.c	/^    int * head;         \/\/ bucket head pointer$/;"	m	struct:_hash	file:
heap_add	util/heap.c	/^void heap_add(Heap * hp, void * pdata){$/;"	f
heap_cmp_fn	output/inc/heap.h	/^    HEAP_CMP_FN heap_cmp_fn;$/;"	m	struct:_heap
heap_cmp_fn	util/heap.h	/^    HEAP_CMP_FN heap_cmp_fn;$/;"	m	struct:_heap
heap_create	util/heap.c	/^Heap * heap_create(int size){$/;"	f
heap_free	util/heap.c	/^void   heap_free(Heap * hp){$/;"	f
heap_item_free_fn	output/inc/heap.h	/^    HEAP_ITEM_FREE heap_item_free_fn;$/;"	m	struct:_heap
heap_item_free_fn	util/heap.h	/^    HEAP_ITEM_FREE heap_item_free_fn;$/;"	m	struct:_heap
heap_pop	util/heap.c	/^void * heap_pop(Heap * hp){$/;"	f
heap_remove	util/heap.c	/^void heap_remove(Heap * hp, void * pdata){$/;"	f
help	src/gblr.c	/^void help() {$/;"	f
help	src/lda.c	/^void help() {$/;"	f
help	src/lr.c	/^void help() {$/;"	f
hessian_v	ts/loess.c	/^static void hessian_v(double *w, double (*hv)[3], int k) {$/;"	f	file:
id	gbdt/tdata.c	/^    int id;$/;"	m	struct:__anon1	file:
id	regr/auc.c	/^    int id;$/;"	m	struct:_aucP	file:
id_doc_map	output/inc/lda.h	/^    char (*id_doc_map)[KEY_SIZE];  \/* doc id map        *\/$/;"	m	struct:_lda
id_doc_map	tm/lda.h	/^    char (*id_doc_map)[KEY_SIZE];  \/* doc id map        *\/$/;"	m	struct:_lda
id_map	gbdt/tdata.h	/^    char (*id_map)[FKL];            \/* feature id name mapping   *\/$/;"	m	struct:__anon2
id_map	output/inc/regress.h	/^    char  (*id_map)[RKL];       \/* feature id map           *\/$/;"	m	struct:_reg
id_map	output/inc/tdata.h	/^    char (*id_map)[FKL];            \/* feature id name mapping   *\/$/;"	m	struct:__anon9
id_map	regr/regress.h	/^    char  (*id_map)[RKL];       \/* feature id map           *\/$/;"	m	struct:_reg
id_v_map	output/inc/lda.h	/^    char (*id_v_map)[KEY_SIZE];    \/* word id map       *\/$/;"	m	struct:_lda
id_v_map	tm/lda.h	/^    char (*id_v_map)[KEY_SIZE];    \/* word id map       *\/$/;"	m	struct:_lda
ids	gbdt/tdata.h	/^    int * ids;                      \/* row ids of feature        *\/$/;"	m	struct:__anon2
ids	output/inc/regress.h	/^    int    *ids;                \/* all feature ids of train *\/$/;"	m	struct:__anon8
ids	output/inc/tdata.h	/^    int * ids;                      \/* row ids of feature        *\/$/;"	m	struct:__anon9
ids	regr/regress.h	/^    int    *ids;                \/* all feature ids of train *\/$/;"	m	struct:__anon12
in_file	output/inc/lda.h	/^    char * in_file;        \/* data in *\/     $/;"	m	struct:__anon4
in_file	output/inc/regress.h	/^    char  *in_file;             \/* input file for train     *\/$/;"	m	struct:__anon7
in_file	regr/regress.h	/^    char  *in_file;             \/* input file for train     *\/$/;"	m	struct:__anon11
in_file	tm/lda.h	/^    char * in_file;        \/* data in *\/     $/;"	m	struct:__anon13
initLogD	ts/modl.c	/^double * initLogD(int L){$/;"	f
init_cents	cls/kmeans.c	/^static int init_cents(float * m, int n, int f, int k, float * cents, float * centsA, int * centsC, int * cids){$/;"	f	file:
init_child	gbdt/dtree.c	/^static void init_child(DTree * t){$/;"	f	file:
init_lda	tm/lda.c	/^int init_lda(Lda *lda) {$/;"	f
init_model	regr/regress.c	/^int init_model(REG * reg){$/;"	f
init_root	gbdt/dtree.c	/^static DTree * init_root(double * g, double * h, int n, double nr, double wr){$/;"	f	file:
iterno	output/inc/regress.h	/^    int    iterno;              \/* current iter number      *\/$/;"	m	struct:__anon7
iterno	regr/regress.h	/^    int    iterno;              \/* current iter number      *\/$/;"	m	struct:__anon11
k	output/inc/lda.h	/^    int    k;              \/* topic n *\/     $/;"	m	struct:__anon4
k	tm/lda.h	/^    int    k;              \/* topic n *\/     $/;"	m	struct:__anon13
key	ts/pattern.c	/^    ULL *key;$/;"	m	struct:_simple_hash_map	file:
kmeans	cls/kmeans.c	/^int kmeans(float * m, int n, int f, int k, int * c){$/;"	f
l	gbdt/tdata.h	/^    int * l;                        \/* row cnt of per feautre    *\/$/;"	m	struct:__anon2
l	output/inc/regress.h	/^    int    *l;                  \/* feature cnt of instances *\/$/;"	m	struct:__anon8
l	output/inc/tdata.h	/^    int * l;                        \/* row cnt of per feautre    *\/$/;"	m	struct:__anon9
l	regr/regress.h	/^    int    *l;                  \/* feature cnt of instances *\/$/;"	m	struct:__anon12
lambda	output/inc/regress.h	/^    double lambda;              \/* penalty for regulization *\/$/;"	m	struct:__anon7
lambda	regr/regress.h	/^    double lambda;              \/* penalty for regulization *\/$/;"	m	struct:__anon11
lcss	ts/dist.c	/^int lcss(int * x, int nx, int *y, int ny){$/;"	f
leaf	gbdt/dtree.c	/^    int leaf;                       \/* is leaf or not, 0 | 1     *\/$/;"	m	struct:_d_tree	file:
learn_model	regr/regress.c	/^int learn_model(REG * reg){$/;"	f
left_max	output/inc/median.h	/^    void * left_max;$/;"	m	struct:_median
left_max	util/median.h	/^    void * left_max;$/;"	m	struct:_median
len	output/inc/heap.h	/^    int len;$/;"	m	struct:_heap
len	util/heap.h	/^    int len;$/;"	m	struct:_heap
lfit	ts/breakout.c	/^static void lfit(double *s, int n, double * l0, double * l1){$/;"	f	file:
load_data	gbdt/tdata.c	/^DTD *(*load_data(char * train_input, char * test_input, int binary))[2]{$/;"	f
load_ds	gbdt/tdata.c	/^static DTD * load_ds(char * input, Hash * hs, int f, int bin){$/;"	f	file:
load_test_ds	regr/regress.c	/^static int load_test_ds(REG * reg, Hash * hs){$/;"	f	file:
load_train_ds	regr/regress.c	/^static int load_train_ds(REG * reg, Hash * hs){$/;"	f	file:
loess	ts/loess.c	/^void loess(double *datax, int n, int span, int robust, double *rety) {$/;"	f
loss	gbdt/dtree.c	/^    double loss;                    \/* loss value of this node   *\/$/;"	m	struct:_d_tree	file:
loss	ts/breakout.c	/^static double loss(double * s, int n){$/;"	f	file:
lr_auc	regr/lr.c	/^double lr_auc(double *x, void *_ds){$/;"	f
lr_eval	regr/lr.c	/^double lr_eval(double *x, void *_ds) {$/;"	f
lr_grad	gbdt/gblr.c	/^void lr_grad(double *f, double *y, double *g, int n){$/;"	f
lr_grad	regr/lr.c	/^void lr_grad(double *x, void *_ds, double *g, double *sg) {$/;"	f
lr_hess	gbdt/gblr.c	/^void lr_hess(double *f, double *y, double *h, int n){$/;"	f
lr_repo	gbdt/gblr.c	/^void lr_repo(GBDT * g){$/;"	f
lr_repo	regr/lr.c	/^int lr_repo(double *x0, double *x1, void *_ds) {$/;"	f
lsp	ts/breakout.c	/^int * lsp(double * ts, int n, int min_size, double beta, int *ol, double * rety){$/;"	f
m_add	util/median.c	/^void m_add(MTrace * m, void *pdata){$/;"	f
m_clear	util/median.c	/^void m_clear(MTrace * m){$/;"	f
m_create	util/median.c	/^MTrace * m_create(CMP_FN cmp_fn, FREE_FN free_fn){$/;"	f
m_free	util/median.c	/^void m_free(MTrace * m){$/;"	f
m_insert_left	util/median.c	/^static void m_insert_left(MTrace * m, void *pdata){$/;"	f	file:
m_insert_right	util/median.c	/^static void m_insert_right(MTrace * m, void * pdata){$/;"	f	file:
m_remove	util/median.c	/^void m_remove(MTrace * m, void * pdata){$/;"	f
main	src/gblr.c	/^int main(int argc, char *argv[]) {$/;"	f
main	src/lda.c	/^int main(int argc, char * argv[]) {$/;"	f
main	src/lr.c	/^int main(int argc, char *argv[]) {$/;"	f
malloc_space	tm/lda.c	/^static void malloc_space(Lda *lda) {$/;"	f	file:
mask	ts/pattern.c	/^    int mask;$/;"	m	struct:_simple_hash_map	file:
mask	util/hash.c	/^    int mask;           \/\/ size - 1$/;"	m	struct:_hash	file:
max	ts/dist.c	/^#define max(/;"	d	file:
max_depth	gbdt/gbdt.h	/^    int max_depth;$/;"	m	struct:_gbdt_param
max_depth	output/inc/gbdt.h	/^    int max_depth;$/;"	m	struct:_gbdt_param
max_leaf_nodes	gbdt/gbdt.h	/^    int max_leaf_nodes;$/;"	m	struct:_gbdt_param
max_leaf_nodes	output/inc/gbdt.h	/^    int max_leaf_nodes;$/;"	m	struct:_gbdt_param
max_size	ts/pattern.c	/^    int max_size;$/;"	m	struct:_cls_list_s	file:
max_trees	gbdt/gbdt.h	/^    int max_trees;$/;"	m	struct:_gbdt_param
max_trees	output/inc/gbdt.h	/^    int max_trees;$/;"	m	struct:_gbdt_param
mean_sd	ts/breakout.c	/^static void mean_sd(double *x, int n, double *mean, double *sd) {$/;"	f	file:
mean_sd	ts/pattern.c	/^void mean_sd(double *x, int n, double *mean, double *sd) {$/;"	f
mergeInterval	ts/modl.c	/^static void mergeInterval(Interval a, Interval b){$/;"	f	file:
method	output/inc/regress.h	/^    int    method;              \/* regualization mod 1 or 2 *\/$/;"	m	struct:__anon7
method	regr/regress.h	/^    int    method;              \/* regualization mod 1 or 2 *\/$/;"	m	struct:__anon11
min	ts/dist.c	/^#define min(/;"	d	file:
modl	ts/modl.c	/^double * modl(double v[], int a[], double * LogD, int n, int * nd){$/;"	f
mt_cmp	util/median.c	/^int mt_cmp(int * m, int *n){$/;"	f
n	gbdt/dtree.c	/^    int n;                          \/* instance num in this node *\/$/;"	m	struct:_d_tree	file:
nd	output/inc/lda.h	/^    ModelEle * nd;                 \/* doc_topic matrix  *\/$/;"	m	struct:_lda
nd	tm/lda.h	/^    ModelEle * nd;                 \/* doc_topic matrix  *\/$/;"	m	struct:_lda
nearest	cls/kmeans.c	/^static int nearest(float * s, float * cents, int c, int f, float * dd){$/;"	f	file:
newton	regr/newton.c	/^int newton(EVAL_FN eval_fn, GRAD_FN grad_fn, REPO_FN repo_fn, NT_METHOD method, void * data, int m, int max_iter, int n, double *retx){$/;"	f
next	output/inc/lda.h	/^    unsigned short next;$/;"	m	struct:__anon5
next	tm/lda.h	/^    unsigned short next;$/;"	m	struct:__anon14
next	ts/pattern.c	/^    int *next;$/;"	m	struct:_simple_hash_map	file:
next	ts/pattern.c	/^    struct _node *next;$/;"	m	struct:_node	typeref:struct:_node::_node	file:
next	util/hash.c	/^    int * next;         \/\/ internal pointer in bucket$/;"	m	struct:_hash	file:
next	util/hash.c	/^    union _la_node * next;$/;"	m	union:_la_node	typeref:union:_la_node::_la_node	file:
next	util/rbtree.c	/^    union _la_node * next;$/;"	m	union:_la_node	typeref:union:_la_node::_la_node	file:
nil	util/rbtree.c	/^    RBNode   * nil;$/;"	m	struct:_RBTree	file:
niters	output/inc/lda.h	/^    int    niters;         \/* iter n  *\/     $/;"	m	struct:__anon4
niters	output/inc/regress.h	/^    int    niters;              \/* max iters                *\/$/;"	m	struct:__anon7
niters	regr/regress.h	/^    int    niters;              \/* max iters                *\/$/;"	m	struct:__anon11
niters	tm/lda.h	/^    int    niters;         \/* iter n  *\/     $/;"	m	struct:__anon13
nkw	output/inc/lda.h	/^    int * nkw;                     \/* token n of topic  *\/$/;"	m	struct:_lda
nkw	tm/lda.h	/^    int * nkw;                     \/* token n of topic  *\/$/;"	m	struct:_lda
nod_reg	gbdt/gbdt.h	/^    double nod_reg;$/;"	m	struct:_gbdt_param
nod_reg	output/inc/gbdt.h	/^    double nod_reg;$/;"	m	struct:_gbdt_param
nw	output/inc/lda.h	/^    ModelEle * nw;                 \/* topic_word matrix *\/$/;"	m	struct:_lda
nw	tm/lda.h	/^    ModelEle * nw;                 \/* topic_word matrix *\/$/;"	m	struct:_lda
objs	cls/Makefile	/^objs    = kmeans.o$/;"	m
objs	gbdt/Makefile	/^objs    = gblr.o gbdt.o dtree.o tdata.o$/;"	m
objs	regr/Makefile	/^objs    = auc.o lr.o regress.o newton.o$/;"	m
objs	tm/Makefile	/^objs    = lda.o$/;"	m
objs	ts/Makefile	/^objs =      breakout.o dist.o    loess.o     modl.o     pattern.o viterbi.o$/;"	m
objs	util/Makefile	/^objs    = hash.o     rbtree.o    str.o       median.o$/;"	m
optimize	ts/modl.c	/^static double optimize(Interval * M, int l,  Interval * I, int m, int n, int *ol, double * LogD){$/;"	f	file:
out_dir	gbdt/gbdt.h	/^    char * out_dir;$/;"	m	struct:_gbdt_param
out_dir	output/inc/gbdt.h	/^    char * out_dir;$/;"	m	struct:_gbdt_param
out_dir	output/inc/lda.h	/^    char * out_dir;        \/* out dir *\/    $/;"	m	struct:__anon4
out_dir	output/inc/regress.h	/^    char  *out_dir;             \/* output dir               *\/$/;"	m	struct:__anon7
out_dir	regr/regress.h	/^    char  *out_dir;             \/* output dir               *\/$/;"	m	struct:__anon11
out_dir	tm/lda.h	/^    char * out_dir;        \/* out dir *\/    $/;"	m	struct:__anon13
p	gbdt/gbdt.c	/^    GBMP p;$/;"	m	struct:_gbdt	file:
p	output/inc/lda.h	/^    ParamLda p;                    \/* lda parameter     *\/$/;"	m	struct:_lda
p	output/inc/regress.h	/^    RP      p;                  \/* Regression parameters    *\/$/;"	m	struct:_reg
p	regr/regress.h	/^    RP      p;                  \/* Regression parameters    *\/$/;"	m	struct:_reg
p	tm/lda.h	/^    ParamLda p;                    \/* lda parameter     *\/$/;"	m	struct:_lda
p	util/hash.c	/^    LANode * p;         \/\/ current aviliable node$/;"	m	struct:_hash	file:
p	util/rbtree.c	/^    RBLANode * p;$/;"	m	struct:_RBTree	file:
p	util/rbtree.c	/^    struct _RBNode * p;$/;"	m	struct:_RBNode	typeref:struct:_RBNode::_RBNode	file:
pData	util/rbtree.c	/^    void * pData;$/;"	m	struct:_RBNode	file:
parse_command_line	src/gblr.c	/^int parse_command_line(GBMP *p, int argc, char *argv[]){$/;"	f
parse_command_line	src/lda.c	/^int parse_command_line(ParamLda *p, int argc, char *argv[]) {$/;"	f
parse_command_line	src/lr.c	/^int parse_command_line(RP *p, int argc, char *argv[]){$/;"	f
pi	ts/breakout.c	/^#define pi /;"	d	file:
pred	ts/loess.c	/^static void pred(double *g, double (*hv)[3], int id, double *rety){$/;"	f	file:
prev	output/inc/lda.h	/^    unsigned short prev;$/;"	m	struct:__anon5
prev	tm/lda.h	/^    unsigned short prev;$/;"	m	struct:__anon14
r	output/inc/regress.h	/^    int     r;                  \/* instance num for train   *\/$/;"	m	struct:__anon8
r	regr/regress.h	/^    int     r;                  \/* instance num for train   *\/$/;"	m	struct:__anon12
r_fn	gbdt/gbdt.c	/^    R r_fn;$/;"	m	struct:_gbdt	file:
randd	cls/kmeans.c	/^static int randd(int d){$/;"	f	file:
randf	cls/kmeans.c	/^static double randf(double s){$/;"	f	file:
rate	gbdt/gbdt.h	/^    double rate;$/;"	m	struct:_gbdt_param
rate	output/inc/gbdt.h	/^    double rate;$/;"	m	struct:_gbdt_param
rb1	output/inc/median.h	/^    RBTree * rb1;$/;"	m	struct:_median
rb1	util/median.h	/^    RBTree * rb1;$/;"	m	struct:_median
rb2	output/inc/median.h	/^    RBTree * rb2;$/;"	m	struct:_median
rb2	util/median.h	/^    RBTree * rb2;$/;"	m	struct:_median
rb_capacity	util/rbtree.c	/^    int rb_capacity;$/;"	m	struct:_RBTree	file:
rb_clear	util/rbtree.c	/^void rb_clear(RBTree * t){$/;"	f
rb_count	util/rbtree.c	/^    int rb_count;$/;"	m	struct:_RBTree	file:
rb_create	util/rbtree.c	/^RBTree * rb_create(CMP_FN cmp_fn, FREE_FN free_fn) {$/;"	f
rb_delete	util/rbtree.c	/^int rb_delete(RBTree *t, void *pdata) {$/;"	f
rb_delete_fix	util/rbtree.c	/^static void rb_delete_fix(RBTree *t, RBNode *z) {$/;"	f	file:
rb_find	util/rbtree.c	/^static RBNode * rb_find(RBTree *t, void *pdata) {$/;"	f	file:
rb_free	util/rbtree.c	/^void rb_free(RBTree * t){$/;"	f
rb_index	util/rbtree.c	/^int  rb_index (RBTree * t, void *data){$/;"	f
rb_insert	util/rbtree.c	/^int rb_insert(RBTree *t, void *pdata) {$/;"	f
rb_insert_fix	util/rbtree.c	/^static void rb_insert_fix(RBTree *t, RBNode *z) {$/;"	f	file:
rb_max_value	util/rbtree.c	/^void * rb_max_value(RBTree *t){$/;"	f
rb_min	util/rbtree.c	/^static RBNode * rb_min(RBTree *t, RBNode *z) {$/;"	f	file:
rb_min_value	util/rbtree.c	/^void * rb_min_value(RBTree *t){$/;"	f
rb_mm	util/rbtree.c	/^static RBNode * rb_mm(RBTree * t, RBNode * z, int d){$/;"	f	file:
rb_node_space	util/rbtree.c	/^    RBLANode * rb_node_space;$/;"	m	struct:_RBTree	file:
rb_trans	util/rbtree.c	/^static void rb_trans(RBTree *t, RBNode *z, RBNode *r) {$/;"	f	file:
rbnode	util/rbtree.c	/^    RBNode rbnode;$/;"	m	union:_la_node	file:
repo_fn	output/inc/regress.h	/^    REPO_FN repo_fn;            \/* report function          *\/$/;"	m	struct:_reg
repo_fn	regr/regress.h	/^    REPO_FN repo_fn;            \/* report function          *\/$/;"	m	struct:_reg
resize_hash	util/hash.c	/^static void resize_hash(Hash * hs){$/;"	f	file:
rets	ts/breakout.c	/^static void rets(double *ts, int n, int *re, int k, double *rety){$/;"	f	file:
right_min	output/inc/median.h	/^    void * right_min;$/;"	m	struct:_median
right_min	util/median.h	/^    void * right_min;$/;"	m	struct:_median
root	util/rbtree.c	/^    RBNode   * root;$/;"	m	struct:_RBTree	file:
rotate	util/rbtree.c	/^static void rotate(RBTree *t, RBNode *z, int d) {$/;"	f	file:
row	gbdt/tdata.h	/^    int row;                        \/* num of instances          *\/$/;"	m	struct:__anon2
row	output/inc/tdata.h	/^    int row;                        \/* num of instances          *\/$/;"	m	struct:__anon9
save_dtree	gbdt/dtree.c	/^void save_dtree(DTree * t, char * out_file, char (*id_map)[FKL]){$/;"	f
save_lda	tm/lda.c	/^void save_lda(Lda *lda, int n) {$/;"	f
save_model	regr/regress.c	/^void save_model(REG * reg, int n){$/;"	f
savestep	output/inc/lda.h	/^    int    savestep;       \/* save s  *\/     $/;"	m	struct:__anon4
savestep	output/inc/regress.h	/^    int    savestep;            \/* save step                *\/$/;"	m	struct:__anon7
savestep	regr/regress.h	/^    int    savestep;            \/* save step                *\/$/;"	m	struct:__anon11
savestep	tm/lda.h	/^    int    savestep;       \/* save s  *\/     $/;"	m	struct:__anon13
scan_tree	gbdt/dtree.c	/^static void scan_tree(DTD * ts, DTree * t, DTree ** inst_nodes, int n, int m){$/;"	f	file:
sg	gbdt/dtree.c	/^    double sg;                      \/* sum of 1-gradient         *\/$/;"	m	struct:_d_tree	file:
sh	gbdt/dtree.c	/^    double sh;                      \/* sum of 2-gradient         *\/$/;"	m	struct:_d_tree	file:
sign	regr/newton.c	/^#define sign(/;"	d	file:
size	output/inc/heap.h	/^    int size;$/;"	m	struct:_heap
size	ts/pattern.c	/^    int size;$/;"	m	struct:_cls_list	file:
size	util/hash.c	/^    int size;           \/\/ number of buckets 2^n$/;"	m	struct:_hash	file:
size	util/heap.h	/^    int size;$/;"	m	struct:_heap
sos	cls/Makefile	/^sos     = libkmeans.so$/;"	m
sos	gbdt/Makefile	/^sos     = libgblr.so libgbdt.so libdtree.so libtdata.so$/;"	m
sos	regr/Makefile	/^sos     = libauc.so liblr.so libnewton.so$/;"	m
sos	tm/Makefile	/^sos     = liblda.so$/;"	m
sos	ts/Makefile	/^sos =       libbrk.so  libdst.so libloess.so libmodl.so libpat.so libvtb.so$/;"	m
sos	util/Makefile	/^sos     = libhs.so   librbt.so   libstr.so   libmed.so$/;"	m
space	util/hash.c	/^    int space;          \/\/ capacity of hash index$/;"	m	struct:_hash	file:
splitInterval	ts/modl.c	/^static double splitInterval(Interval t, Interval sp1, Interval sp2, Interval * I, int l, int m, int n, double * LogD){$/;"	f	file:
statics	cls/Makefile	/^statics = libkmeanss.a$/;"	m
statics	gbdt/Makefile	/^statics = libgblrs.a libgbdts.a libdtrees.a libtdatas.a$/;"	m
statics	regr/Makefile	/^statics = libaucs.a liblrs.a libnewtons.a$/;"	m
statics	tm/Makefile	/^statics = libldas.a$/;"	m
statics	ts/Makefile	/^statics =   libbrks.a  libdsts.a libloesss.a libmodls.a libpats.a libvtbs.a$/;"	m
statics	util/Makefile	/^statics = libhss.a   librbts.a   libstrs.a   libmeds.a$/;"	m
strsep	util/str.c	/^char *strsep(char **stringp, const char *delim) {$/;"	f
strval	util/hash.c	/^    char * strval;$/;"	m	union:_hash_val	file:
studentpdf	ts/breakout.c	/^static double studentpdf(double x, double mu, double var, double nu) {$/;"	f	file:
sub	ts/pattern.c	/^    int sub[2];$/;"	m	struct:_node	file:
sz	ts/pattern.c	/^    int sz;$/;"	m	struct:_cls_list_s	file:
sz	ts/pattern.c	/^    int sz;$/;"	m	struct:_simple_hash_map	file:
t	gbdt/gbdt.c	/^    double * t;$/;"	m	struct:_gbdt	file:
t	output/inc/lda.h	/^    int t;                         \/* token size        *\/$/;"	m	struct:_lda
t	tm/lda.h	/^    int t;                         \/* token size        *\/$/;"	m	struct:_lda
t_label	gbdt/gbdt.c	/^double * t_label(GBDT * gbdt){$/;"	f
t_model	gbdt/gbdt.c	/^double * t_model(GBDT * gbdt){$/;"	f
t_rowns	gbdt/gbdt.c	/^int t_rowns(GBDT * gbdt){$/;"	f
t_size	gbdt/gbdt.c	/^int t_size(GBDT * gbdt){$/;"	f
tabulate	ts/breakout.c	/^static void tabulate(int *x, int n, int *t1, int *t2, int *tot) {$/;"	f	file:
tail	ts/pattern.c	/^    Node *tail;$/;"	m	struct:_cls_list	file:
tdt_fea_cmp	gbdt/tdata.c	/^static int tdt_fea_cmp(const void * a1, const void * a2){$/;"	f	file:
te_file	output/inc/regress.h	/^    char  *te_file;             \/* input file for test      *\/$/;"	m	struct:__anon7
te_file	regr/regress.h	/^    char  *te_file;             \/* input file for test      *\/$/;"	m	struct:__anon11
test_ds	gbdt/gbdt.c	/^    DTD *  test_ds;$/;"	m	struct:_gbdt	file:
test_ds	output/inc/regress.h	/^    RDS   *  test_ds;           \/* test  dataset pointer    *\/$/;"	m	struct:_reg
test_ds	regr/regress.h	/^    RDS   *  test_ds;           \/* test  dataset pointer    *\/$/;"	m	struct:_reg
test_input	gbdt/gbdt.h	/^    char * test_input;$/;"	m	struct:_gbdt_param
test_input	output/inc/gbdt.h	/^    char * test_input;$/;"	m	struct:_gbdt_param
tiedrank	regr/auc.c	/^void tiedrank(int n, AucP *aucp, double *rk) {$/;"	f
tokens	output/inc/lda.h	/^    int  (*tokens)[4];             \/* tokens            *\/$/;"	m	struct:_lda
tokens	tm/lda.h	/^    int  (*tokens)[4];             \/* tokens            *\/$/;"	m	struct:_lda
train_ds	gbdt/gbdt.c	/^    DTD * train_ds;$/;"	m	struct:_gbdt	file:
train_ds	output/inc/regress.h	/^    RDS   * train_ds;           \/* train dataset pointer    *\/$/;"	m	struct:_reg
train_ds	regr/regress.h	/^    RDS   * train_ds;           \/* train dataset pointer    *\/$/;"	m	struct:_reg
train_input	gbdt/gbdt.h	/^    char * train_input;$/;"	m	struct:_gbdt_param
train_input	output/inc/gbdt.h	/^    char * train_input;$/;"	m	struct:_gbdt_param
tree_grow	gbdt/dtree.c	/^static int tree_grow(DTD * ds$/;"	f	file:
tree_size	gbdt/gbdt.c	/^    int tree_size;$/;"	m	struct:_gbdt	file:
trim	util/str.c	/^char * trim(char *c, int mode){$/;"	f
type	util/hash.c	/^    HashType type;      \/\/ INT, LONG, STRING$/;"	m	struct:_hash	file:
uival	util/hash.c	/^    unsigned int uival;$/;"	m	union:_hash_val	file:
ulval	util/hash.c	/^    unsigned long long ulval;$/;"	m	union:_hash_val	file:
update_child	gbdt/dtree.c	/^static void update_child(DTree * t, int k, int lc, double lsg, double lsh, double nr, double wr, double v, double lv){$/;"	f	file:
v	output/inc/lda.h	/^    int v;                         \/* dict size         *\/$/;"	m	struct:_lda
v	tm/lda.h	/^    int v;                         \/* dict size         *\/$/;"	m	struct:_lda
val	gbdt/tdata.c	/^    double val;$/;"	m	struct:__anon1	file:
val	output/inc/regress.h	/^    double *val;                \/* all feature val of train *\/$/;"	m	struct:__anon8
val	regr/regress.h	/^    double *val;                \/* all feature val of train *\/$/;"	m	struct:__anon12
vals	gbdt/tdata.h	/^    double * vals;                  \/* row feature value         *\/$/;"	m	struct:__anon2
vals	output/inc/tdata.h	/^    double * vals;                  \/* row feature value         *\/$/;"	m	struct:__anon9
vals	util/hash.c	/^    LANode * vals;      \/\/ data space for HashVal$/;"	m	struct:_hash	file:
value	util/hash.c	/^    HashVal value;$/;"	m	union:_la_node	file:
viterbi	ts/viterbi.c	/^int viterbi(int * l, int * o, int n, int r_t, int r_o){$/;"	f
w_regr	ts/loess.c	/^void w_regr(double *y, double *w, int s, int id, double * rv) {$/;"	f
wei	gbdt/dtree.c	/^    double wei;                     \/* additive model value      *\/$/;"	m	struct:_d_tree	file:
wei_reg	gbdt/gbdt.h	/^    double wei_reg;$/;"	m	struct:_gbdt_param
wei_reg	output/inc/gbdt.h	/^    double wei_reg;$/;"	m	struct:_gbdt_param
x	output/inc/regress.h	/^    double *x;                  \/* learned weight result    *\/$/;"	m	struct:_reg
x	regr/auc.c	/^    double x;$/;"	m	struct:_aucP	file:
x	regr/regress.h	/^    double *x;                  \/* learned weight result    *\/$/;"	m	struct:_reg
y	gbdt/tdata.h	/^    double * y;                     \/* labels of data            *\/$/;"	m	struct:__anon2
y	output/inc/regress.h	/^    double *y;                  \/* target label of train    *\/$/;"	m	struct:__anon8
y	output/inc/tdata.h	/^    double * y;                     \/* labels of data            *\/$/;"	m	struct:__anon9
y	regr/regress.h	/^    double *y;                  \/* target label of train    *\/$/;"	m	struct:__anon12
y_label	gbdt/gbdt.c	/^double * y_label(GBDT * gbdt){$/;"	f
y_model	gbdt/gbdt.c	/^double * y_model(GBDT * gbdt){$/;"	f
y_rowns	gbdt/gbdt.c	/^int y_rowns(GBDT * gbdt){$/;"	f
z_norm	ts/breakout.c	/^static void z_norm(double *x, int n, double *nx) {$/;"	f	file:
z_norm	ts/pattern.c	/^void z_norm(double *x, int n, double *nx){$/;"	f
